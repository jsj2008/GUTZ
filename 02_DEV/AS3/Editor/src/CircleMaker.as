package {		import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.Graphics;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.display.Stage;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle;		public class CircleMaker {				private var _stage:Stage;				private var _root_sprite:Sprite;		private var _guide_sprite:Sprite;		private var _gfx_sprite:Sprite;		private var _debug_sprite:Sprite;				private var _src_mc:MovieClip;		private var _src_bmpData:BitmapData;		private var _fill_bmpData:BitmapData;		private var _bmpHolder_sprite:Sprite;				private var _dim_rect:Rectangle;		private var _center_pt:Point;		private var _cardinal_arr:Array;		private var _rndDir_arr:Array;		private var _strokePt_arr:Array;						private var _circleVO_arr:Array;		private var _jointVO_arr:Array;		private var _plist_str:String;				private var _area:Number;				private static const DEGREES_MULT:Number = 0.0174532925;		private static const ROOT_TWO:Number = Math.sqrt(2);				private static const NN_DIR:Point = new Point(0, -1);		private static const NE_DIR:Point = new Point(ROOT_TWO, -ROOT_TWO);		private static const EE_DIR:Point = new Point(1, 0);		private static const SE_DIR:Point = new Point(ROOT_TWO, ROOT_TWO);		private static const SS_DIR:Point = new Point(1, 0);		private static const SW_DIR:Point = new Point(-ROOT_TWO, ROOT_TWO);		private static const WW_DIR:Point = new Point(-1, 0);		private static const NW_DIR:Point = new Point(-ROOT_TWO, -ROOT_TWO);				private static const SCREEN_SIZE_RECT:Rectangle = new Rectangle(0, 0, 320, 480);		private static const SCREEN_CENTER_POS:Point = new Point(SCREEN_SIZE_RECT.width * 0.5, SCREEN_SIZE_RECT.height * 0.5);		private static const ASSET_SIZE:Rectangle = new Rectangle(45, 120, 90, 240);		//private static const ASSET_SIZE:Rectangle = new Rectangle(88, 175, 176, 350);				private static const NEUTRAL_GREY:uint = 0x330066;		private static const CIRCLE_STROKE:uint = 0x00ff00;		private static const CIRCLE_FILL:uint = 0x330066;		private static const EDGE_COLOR:uint = 0x000000;		private static const DEBUG_STROKE:uint = 0x00ff00;		private static const DEBUG_FILL:uint = 0xff00ff;		private static const GUIDE_STROKE:uint = 0x00afaf;		private static const BOUNDS_COLOR:uint = 0x00ffff;				private static const MAX_ATTEMPTS:int = 100;		private static const MAX_PERIMETER:int = 100;				private static const FAIL_CUTOFF:int = 2;		private static const RADIUS_LIMITS:Point = new Point(3, 50);				private static const OFFSET_RND:int = ((Math.random() * 16) << 0) + 4;				private static const SPRING_STR:Number = Number(((Math.random() * 32) + 4).toFixed(6));		private static const SPRING_DAMP:Number = Number(((Math.random() * 0.33) + 0.5).toFixed(6));						private static const PLIST_HEAD:String = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n";				private static const CIRCLE_PREGRP:String = "\t<key>circles</key>\n\t<array>\n";		private static const CIRCLE_POSTGRP:String = "\t</array>\n";		private static const CIRCLE_PRETAG:String = "\t\t<dict>\n\t\t\t<key>id</key>\n\t\t\t<integer>";		private static const CIRCLE_POS_X:String = "</integer>\n\t\t\t<key>x</key>\n\t\t\t<integer>";		private static const CIRCLE_POS_Y:String = "</integer>\n\t\t\t<key>y</key>\n\t\t\t<integer>";		private static const CIRCLE_RADIUS:String = "</integer>\n\t\t\t<key>radius</key>\n\t\t\t<integer>";		private static const CIRCLE_POSTTAG:String ="</integer>\n\t\t</dict>\n";				private static const JOINT_PREGRP:String = "\t<key>joints</key>\n\t<array>\n";		private static const JOINT_POSTGRP:String = "\t</array>\n";		private static const JOINT_PRETAG:String = "\t\t<dict>\n\t\t\t<key>id</key>\n\t\t\t<integer>";		private static const JOINT_BODY_A:String = "</integer>\n\t\t\t<key>body1</key>\n\t\t\t<integer>";		private static const JOINT_BODY_B:String = "</integer>\n\t\t\t<key>body2</key>\n\t\t\t<integer>";		private static const JOINT_STR:String = "</integer>\n\t\t\t<key>str</key>\n\t\t\t<real>";		private static const JOINT_DMP:String = "</real>\n\t\t\t<key>damp</key>\n\t\t\t<real>";		private static const JOINT_POSTTAG:String ="</real>\n\t\t</dict>\n";				private static const PLIST_TAIL:String = "</dict>\n</plist>"						public function CircleMaker(stage_ref:Stage) {						_stage = stage_ref;						_rndDir_arr = new Array();						_cardinal_arr = new Array();			_cardinal_arr.push(EE_DIR);			_cardinal_arr.push(SS_DIR);			_cardinal_arr.push(WW_DIR);			_cardinal_arr.push(NN_DIR);			_cardinal_arr.push(NE_DIR);			_cardinal_arr.push(SE_DIR);			_cardinal_arr.push(SW_DIR);			_cardinal_arr.push(NW_DIR);									this.rndCardinals();									_circleVO_arr = new Array();			_jointVO_arr = new Array();						_strokePt_arr = new Array();						_plist_str = "";			_area = 0.0;						_root_sprite = new Sprite();			_root_sprite.x = SCREEN_CENTER_POS.x;			_root_sprite.y = SCREEN_CENTER_POS.y;			_stage.addChild(_root_sprite);						_bmpHolder_sprite = new Sprite();			_gfx_sprite = new Sprite();			_debug_sprite = new Sprite();						_root_sprite.addChild(_bmpHolder_sprite);			_root_sprite.addChild(_gfx_sprite);			_root_sprite.addChild(_debug_sprite);						guideSetup();		}						public function addShape(trg_mc:MovieClip):void {						_dim_rect = new Rectangle((trg_mc.width * 0.5) << 0, (trg_mc.height * 0.5) << 0, trg_mc.width, trg_mc.height);			_center_pt = new Point(_dim_rect.x, _dim_rect.y);									_src_mc = trg_mc;			//_src_mc.x = -_dim_rect.width;			//_src_mc.y = -_dim_rect.height;						_src_bmpData = new BitmapData(_dim_rect.width, _dim_rect.height, false, BOUNDS_COLOR);			_src_bmpData.draw(_src_mc);//, new Matrix(1, 0, 0, 1, _center_pt.x, _center_pt.y));									var holder_sprite:Sprite = new Sprite();				holder_sprite.x = -_center_pt.x;				holder_sprite.y = -_center_pt.y;				holder_sprite.addChild(new Bitmap(_src_bmpData));									_bmpHolder_sprite.addChild(holder_sprite);									//this.buildEdgeCoords();					}						public function fillShape():void {			this.buildCircles();			this.makeJoints();		}				private function buildCircles():void {						var rad:int;						var fill_cnt:int = 0;			var fail_cnt:int = 0;						var fill_pt:Point = _center_pt.clone();			var old_pt:Point = new Point();									rad = this.testRadials(new Point(0, 0), RADIUS_LIMITS.y);			this.drawCircle(new Point(), rad);									while (fill_cnt < MAX_ATTEMPTS) {								old_pt = fill_pt.clone();				rad = this.testRadials(fill_pt, RADIUS_LIMITS.y);								if (rad < RADIUS_LIMITS.x || rad > RADIUS_LIMITS.y) {					fail_cnt++;										if (fail_cnt < FAIL_CUTOFF)						fill_pt = old_pt.clone();										else {						fill_pt = new Point((Math.random() * _dim_rect.width) << 0, (Math.random() * _dim_rect.height) << 0);						fail_cnt = 0;					}									} else {					fill_pt = fill_pt.subtract(_center_pt);										//trace ("]>> FILLING #("+fill_cnt+") POS:["+fill_pt+"] RAD:["+rad+"]");					this.drawCircle(fill_pt, rad);					_src_bmpData.draw(_bmpHolder_sprite, new Matrix(1, 0, 0, 1, _center_pt.x, _center_pt.y));										_circleVO_arr.push(new CircleVO(fill_cnt++, fill_pt, rad));									}								fill_pt = fill_pt.add(this.offsetPt(rad));				//trace ("MOVING TO:["+fill_pt+"]\n[=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=]\n");			}		}				private function offsetPt(amt:int):Point {						var offset_pt:Point = new Point();						switch ((Math.random() * 4) << 0) {				case 0:					offset_pt.x = amt + OFFSET_RND;					break;										case 1:					offset_pt.x = -(amt + OFFSET_RND);					break;										case 2:					offset_pt.y = amt + OFFSET_RND;					break;										case 3:					offset_pt.y = -(amt + OFFSET_RND);					break;			}					return (offset_pt);		}				private function drawCircle(pos:Point, rad:int):void {						var g:Graphics;						g = _bmpHolder_sprite.graphics;			g.lineStyle(0, CIRCLE_STROKE, 0.00);			g.beginFill(CIRCLE_FILL);			g.drawCircle(pos.x, pos.y, rad);			g.endFill();						g = _gfx_sprite.graphics;			g.lineStyle(1, CIRCLE_STROKE);			g.beginFill(CIRCLE_FILL);			g.drawCircle(pos.x, pos.y, rad);			g.endFill();		}						private function testRadials(pos:Point, max:int):int {						for (var i:int=0; i<max; i++) {				var dist:int;				var testPos_pt:Point = new Point();				var offset_pt:Point = new Point();				var pixel_color:int;				var r_amt:int;				var g_amt:int;				var b_amt:int;								var ang_inc:int = 0;								for (var j:int=0; j<36; j++) {										ang_inc = j * 10;										testPos_pt.x = (pos.x + (Math.sin(DEGREES_MULT * ang_inc) * i)) << 0;					testPos_pt.y = (pos.y + (Math.cos(DEGREES_MULT * ang_inc) * i)) << 0;										pixel_color = _src_bmpData.getPixel(testPos_pt.x, testPos_pt.y);										if (pixel_color == BOUNDS_COLOR)						return (-1);										if (pixel_color == CIRCLE_FILL) {												offset_pt.x = Math.abs(testPos_pt.x - pos.x) << 0;						offset_pt.y = Math.abs(testPos_pt.y - pos.y) << 0;											//trace (">> RAD:["+i+"] ANG:["+j+"] POS:["+(testPos_pt.x-pos.x)+", "+(testPos_pt.y-pos.y)+"] COLOR:["+pixel_color+"] RGB:["+r_amt+","+g_amt+","+b_amt+"]");																		if (offset_pt.x > offset_pt.y)							return (offset_pt.x);												else							return (offset_pt.y);					}				}			}									return (0);		}						public function buildEdgeCoords():void {						var edge_cnt:int = 0;			var edge_ind:int = 0;						// find the nearest edge			var old_pt:Point = new Point();			var edge_pt:Point = this.firstEdgeFinder(_center_pt);			var offset_pt:Point = new Point();									trace ("\\\\\\\]>> 1st NEAREST EDGE @ ["+edge_pt+"]");									// not (0, 0)			if (!edge_pt.equals(new Point())) {								_debug_sprite.graphics.lineStyle(1, DEBUG_STROKE);				_debug_sprite.graphics.moveTo(edge_pt.x, edge_pt.y);																_strokePt_arr.push(edge_pt);				edge_ind++;								// position w/ continued stroke				offset_pt = this.adjEdgeFinder(new Point(edge_pt.x + _center_pt.x, edge_pt.y + _center_pt.y));												edge_pt.x += offset_pt.x;				edge_pt.y += offset_pt.y;								_debug_sprite.graphics.lineTo(edge_pt.x, edge_pt.y);												//trace ("\\\\\\\]>> 2nd @ COORDS:["+edge_pt+"]");												// loop until back at the start				//while (!(_strokePt_arr[0] as Point).equals(edge_pt) && edge_cnt < MAX_PERIMETER) {				while (edge_cnt < MAX_PERIMETER) {										trace ("[-\-] LOOPING["+edge_cnt+"]>> @ ["+(edge_pt.x + _center_pt.x)+", "+(edge_pt.y + _center_pt.y)+"] // ["+offset_pt+"]");															offset_pt = this.adjEdgeFinder(edge_pt);										// found an adj stroke					if (offset_pt) {																		old_pt = edge_pt;						edge_pt.x += offset_pt.x;						edge_pt.y += offset_pt.y;												trace (" —-\\> FOUND ADJ @ ["+offset_pt+"] // ["+(edge_pt.x + _center_pt.x)+", "+(edge_pt.y + _center_pt.y)+"]<\\\\-— ");						_strokePt_arr.push(edge_pt);						edge_ind++;												var g:Graphics = _debug_sprite.graphics;							g.lineStyle(1, DEBUG_STROKE);							g.lineTo(edge_pt.x, edge_pt.y);							g.moveTo(old_pt.x, old_pt.y);										} else {						edge_pt = old_pt;					}															//edge_pt = this.adjEdgeFinder(edge_pt.subtract(offset_pt));										edge_cnt++;					trace ("[=-=-=-=-=-=-=-=-=-+=EOL=+-=-=-=-=-=-=-=-=-=]\n");				}			}		}						private function firstEdgeFinder(pos:Point):Point {						var rgbVO:ColorVO = new ColorVO();			var dist:int;			var testPos_pt:Point = new Point();			var offset_pt:Point = new Point();			var pixel_color:int;						var r_amt:int;			var g_amt:int;			var b_amt:int;									for (var i:int=0; i<RADIUS_LIMITS.y; i++) {								// loop thru all degrees				for (var j:int=0; j<360; j++) {										// coords to test					testPos_pt.x = (pos.x + (Math.sin(DEGREES_MULT * j) * i)) << 0;					testPos_pt.y = (pos.y + (Math.cos(DEGREES_MULT * j) * i)) << 0;										pixel_color = _src_bmpData.getPixel(testPos_pt.x, testPos_pt.y);										if (pixel_color == EDGE_COLOR) {												rgbVO.setRGBColors((pixel_color >> 16) & 0xff, (pixel_color >> 8) & 0xff, (pixel_color >> 0) & 0xff);												offset_pt.x = (testPos_pt.x - pos.x) << 0;						offset_pt.y = (testPos_pt.y - pos.y) << 0;											trace (">> RAD:["+i+"] ANG:["+j+"] POS:["+(testPos_pt.x-pos.x)+", "+(testPos_pt.y-pos.y)+"] COLOR:["+pixel_color+"] RGB:["+rgbVO.red+","+rgbVO.green+","+rgbVO.blue+"]");																		return (offset_pt);					}				}			}									return (null);		}						private function rndCardinals():void {						var i:Number;			var tmp_ind:int;			var rnd_ind:int;						_rndDir_arr = new Array();						for (i=0; i<_cardinal_arr.length; i++)				_rndDir_arr.push(_cardinal_arr[i]);											for (i=(_rndDir_arr.length-1); i>0; i--) {				rnd_ind = (Math.random() * (i-1)) << 0;				tmp_ind = _rndDir_arr[i];								_rndDir_arr[i] = rnd_ind;				_rndDir_arr[rnd_ind] = tmp_ind;			}									//tmp_ind = _rndDir_arr[0];			//rnd_ind = 1 + (Math.random() * (_rndDir_arr.length-2) << 0);			//_rndDir_arr[0] = rnd_ind;			//_rndDir_arr[rnd_ind] = tmp_ind;								}								private function rndArrayInd(in_arr:Array):int {						return (in_arr[(Math.random() * (in_arr.length-1))] << 0);					}				private function adjEdgeFinder(org_pt:Point):Point {						var tst_pt:Point = org_pt;			var cardinal_pt:Point = new Point();			var rgbVO:ColorVO = new ColorVO();			var pixel_color:uint;																		var isDir:Boolean = false;						for (var i:Number=0; i<_cardinal_arr.length; i++) {								// pull out the direction				cardinal_pt = _cardinal_arr[i] as Point;								// add to start pos				tst_pt.x += cardinal_pt.x;				tst_pt.y += cardinal_pt.y;								// swab the color as rgb				pixel_color = _src_bmpData.getPixel(tst_pt.x + _center_pt.x, tst_pt.y + _center_pt.y);								/*for (var q:int=0; q<100; q++) {					for (var w:int=0; w<100; w++) {						trace ("::::::::("+q+", "+w+") = ["+_src_bmpData.getPixel(q, w)+"[::::::::");					}				}*/												rgbVO.setRGBColors((pixel_color >> 16) & 0xff, (pixel_color >> 8) & 0xff, (pixel_color >> 0) & 0xff);								//trace (">> DIR:["+i+"]="+cardinal_pt+" POS:["+tst_pt.x+", "+tst_pt.y+"] COLOR:["+pixel_color+"]("+(pixel_color == EDGE_COLOR)+") RGB:["+rgbVO.red+","+rgbVO.green+","+rgbVO.blue+"]");								// still on the stroke				if (pixel_color == EDGE_COLOR)					return (cardinal_pt);			}						return (null);												/*			var pixel_color:uint;			var this.testCardinals(fill_pt, RADIUS_LIMITS.y)			// start the crawl			var tst_pt:Point = org_pt.clone();			var dir_pt:Point = new Point();						for (var i:Number=0; i<_cardinal_arr.length; i++) {				dir_pt = (_cardinal_arr[i] as Point).clone();				tst_pt.add(dir_pt);				pixel_color = _src_bmpData.getPixel(tst_pt.x, tst_pt.y);												// still on the stroke				if (pixel_color -= 0x000000) {					_strokePt_arr.push(tst_pt);					org_pt = tst_pt.clone();					break;				}			}			*/		}								public function calcArea():Number {						_center_pt = new Point(ASSET_SIZE.x, ASSET_SIZE.y);									var dist_base:int = 70;			var dist_offset:int = 10;						var i:Number;			var curr_pt:Point;			var next_pt:Point;						var area:Number = 0;												var vert_arr:Array = new Array();						for (i=0; i<36; i++)				vert_arr.push(new Point(Math.sin((i * 10) * DEGREES_MULT) * (dist_base + (Math.random() * dist_offset)) << 0, Math.cos((i * 10) * DEGREES_MULT) * (dist_base + (Math.random() * dist_offset)) << 0));						for (i=0; i<vert_arr.length; i++) {				curr_pt = vert_arr[i] as Point;				next_pt = vert_arr[((i+1) % (vert_arr.length-1))] as Point;								var g:Graphics = _debug_sprite.graphics;					g.lineStyle(1, DEBUG_STROKE);					g.beginFill(DEBUG_FILL);					g.drawCircle(curr_pt.x, curr_pt.y, 4);					g.endFill();										g.lineTo(next_pt.x, next_pt.y);					g.moveTo(curr_pt.x, curr_pt.y);										area += ((curr_pt.y - next_pt.y) * (curr_pt.x + next_pt.x));			}						area *= 0.5;						trace ("SHAPE AREA:["+area+"]");			return (area);		}				private function makeJoints():void {						var currVO:CircleVO;			var nextVO:CircleVO;						var g:Graphics = _gfx_sprite.graphics;				g.lineStyle(1, 0xff0000);							for (var i:Number=0; i<_circleVO_arr.length; i++) {				currVO = _circleVO_arr[i] as CircleVO;				nextVO = _circleVO_arr[i % (_circleVO_arr.length - 1)] as CircleVO;								//g.lineTo(currVO.pos_pt.x, currVO.pos_pt.y);				//g.moveTo(nextVO.pos_pt.x, nextVO.pos_pt.y);								_jointVO_arr.push(new JointVO(i, currVO.id, nextVO.id, new Point(), new Point(), SPRING_STR, SPRING_DAMP));			}		}						public function writePlist():String {						_plist_str += PLIST_HEAD;			_plist_str += this.writeCircles();			_plist_str += this.writeJoints();			_plist_str += PLIST_TAIL;											return (_plist_str);					}				private function writeCircles():String {						var str:String = CIRCLE_PREGRP;						for (var i:Number=0; i<_circleVO_arr.length; i++) {				str += CIRCLE_PRETAG + String((_circleVO_arr[i] as CircleVO).id);				str += CIRCLE_POS_X + String((_circleVO_arr[i] as CircleVO).pos_pt.x);				str += CIRCLE_POS_Y + String((_circleVO_arr[i] as CircleVO).pos_pt.y);				str += CIRCLE_RADIUS + String((_circleVO_arr[i] as CircleVO).radius);				str += CIRCLE_POSTTAG;			}						return (str + CIRCLE_POSTGRP);		}								private function writeJoints():String {						var str:String = JOINT_PREGRP;						for (var i:Number=0; i<_jointVO_arr.length; i++) {				str += JOINT_PRETAG + String((_jointVO_arr[i] as JointVO).id);				str += JOINT_BODY_A + String((_jointVO_arr[i] as JointVO).bodyA);				str += JOINT_BODY_B + String((_jointVO_arr[i] as JointVO).bodyB);				str += JOINT_STR + String((_jointVO_arr[i] as JointVO).str);				str += JOINT_DMP + String((_jointVO_arr[i] as JointVO).dmp);				str += JOINT_POSTTAG;			}						return (str + JOINT_POSTGRP);		}						private function guideSetup():void {						var rad:int = 200;									_guide_sprite = new Sprite();						var g:Graphics = _guide_sprite.graphics;				g.lineStyle(1, GUIDE_STROKE);				g.moveTo(0, 0);				g.lineTo(0, -rad * 0.6);				g.moveTo(0, 0);				g.lineTo(rad * 0.6, 0);				g.moveTo(0, 0);				g.lineTo(0, rad * 0.6);				g.moveTo(0, 0);				g.lineTo(-rad * 0.6, 0);				g.moveTo(0, 0);				g.drawCircle(0, 0, rad * 0.5);											_root_sprite.addChild(_guide_sprite);					}						private function dummyPopulate(amt:int):void {						var i:Number;						for (i=0; i<amt; i++)				_circleVO_arr.push(new CircleVO(i, new Point(i, i), ((Math.random() * 62) << 0) + 2));											for (i=0; i<amt; i++)				_jointVO_arr.push(new JointVO(i, i, (i % 9), new Point(), new Point(), (Math.random() * 62) + 2, Math.random()));					}	}}
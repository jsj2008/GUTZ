package {		import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.Graphics;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.display.Stage;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle;		public class CircleMaker {				private var _stage:Stage;				private var _root_sprite:Sprite;		private var _guide_sprite:Sprite;		private var _gfx_sprite:Sprite;		private var _debug_sprite:Sprite;				private var _src_mc:MovieClip;		private var _src_bmpData:BitmapData;		private var _fill_bmpData:BitmapData;		private var _bmpHolder_sprite:Sprite;				private var _dim_rect:Rectangle;		private var _center_pt:Point;				private var _circleVO_arr:Array;		private var _jointVO_arr:Array;		private var _plist_str:String;				private static const DEGREES_MULT:Number = 0.0174532925;				private static const SCREEN_SIZE_RECT:Rectangle = new Rectangle(0, 0, 320, 480);		private static const SCREEN_CENTER_POS:Point = new Point(SCREEN_SIZE_RECT.width * 0.5, SCREEN_SIZE_RECT.height * 0.5);				private static const NEUTRAL_GREY:uint = 0x808080;		private static const CIRCLE_STROKE:uint = 0x00ff00;		private static const CIRCLE_FILL:uint = 0x000000;		private static const BOUNDS_COLOR:uint = 0xffffff;				private static const MAX_ATTEMPTS:int = 128;		private static const FAIL_CUTOFF:int = 2;		private static const RADIUS_LIMITS:Point = new Point(3, 20);				private static const OFFSET_RND:int = ((Math.random() * 16) << 0) + 4;				private static const SPRING_STR:Number = Number(((Math.random() * 32) + 4).toFixed(6));		private static const SPRING_DAMP:Number = Number(((Math.random() * 0.33) + 0.5).toFixed(6));						private static const PLIST_HEAD:String = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n";				private static const CIRCLE_PREGRP:String = "\t<key>circles</key>\n\t<array>\n";		private static const CIRCLE_POSTGRP:String = "\t</array>\n";		private static const CIRCLE_PRETAG:String = "\t\t<dict>\n\t\t\t<key>id</key>\n\t\t\t<integer>";		private static const CIRCLE_POS_X:String = "</integer>\n\t\t\t<key>x</key>\n\t\t\t<integer>";		private static const CIRCLE_POS_Y:String = "</integer>\n\t\t\t<key>y</key>\n\t\t\t<integer>";		private static const CIRCLE_RADIUS:String = "</integer>\n\t\t\t<key>radius</key>\n\t\t\t<integer>";		private static const CIRCLE_POSTTAG:String ="</integer>\n\t\t</dict>\n";				private static const JOINT_PREGRP:String = "\t<key>joints</key>\n\t<array>\n";		private static const JOINT_POSTGRP:String = "\t</array>\n";		private static const JOINT_PRETAG:String = "\t\t<dict>\n\t\t\t<key>id</key>\n\t\t\t<integer>";		private static const JOINT_BODY_A:String = "</integer>\n\t\t\t<key>body1</key>\n\t\t\t<integer>";		private static const JOINT_BODY_B:String = "</integer>\n\t\t\t<key>body2</key>\n\t\t\t<integer>";		private static const JOINT_STR:String = "</integer>\n\t\t\t<key>str</key>\n\t\t\t<real>";		private static const JOINT_DMP:String = "</real>\n\t\t\t<key>damp</key>\n\t\t\t<real>";		private static const JOINT_POSTTAG:String ="</real>\n\t\t</dict>\n";				private static const PLIST_TAIL:String = "</dict>\n</plist>"						public function CircleMaker(stage_ref:Stage) {						_stage = stage_ref;						_circleVO_arr = new Array();			_jointVO_arr = new Array();						_plist_str = "";						_root_sprite = new Sprite();			_root_sprite.x = SCREEN_CENTER_POS.x;			_root_sprite.y = SCREEN_CENTER_POS.y;			_stage.addChild(_root_sprite);						_bmpHolder_sprite = new Sprite();			_gfx_sprite = new Sprite();			_debug_sprite = new Sprite();						_root_sprite.addChild(_bmpHolder_sprite);			//_root_sprite.addChild(_gfx_sprite);			_root_sprite.addChild(_debug_sprite);						guideSetup();		}						public function addShape(trg_mc:MovieClip):void {						_dim_rect = new Rectangle((trg_mc.width * 0.5) << 0, (trg_mc.height * 0.5) << 0, trg_mc.width, trg_mc.height);			_center_pt = new Point(_dim_rect.x, _dim_rect.y);									_src_mc = trg_mc;			_src_mc.x = -_dim_rect.width;			_src_mc.y = -_dim_rect.height;						_src_bmpData = new BitmapData(_dim_rect.width, _dim_rect.height, true, 0xffffff);			_src_bmpData.draw(_src_mc, new Matrix(1, 0, 0, 1, _center_pt.x, _center_pt.y));									var holder_sprite:Sprite = new Sprite();				holder_sprite.x = -_center_pt.x;				holder_sprite.y = -_center_pt.y;				holder_sprite.addChild(new Bitmap(_src_bmpData));									_bmpHolder_sprite.addChild(holder_sprite);						this.buildCircles();			this.makeJoints();		}						private function buildCircles():void {						var rad:int;						var fill_cnt:int = 0;			var fail_cnt:int = 0;						var fill_pt:Point = _center_pt.clone();			var old_pt:Point = new Point();									rad = this.testRadials(new Point(0, 0), RADIUS_LIMITS.y);			this.drawCircle(new Point(), rad);									while (fill_cnt < MAX_ATTEMPTS) {								old_pt = fill_pt.clone();				rad = this.testRadials(fill_pt, RADIUS_LIMITS.y);								if (rad < RADIUS_LIMITS.x || rad > RADIUS_LIMITS.y) {					fail_cnt++;										if (fail_cnt < FAIL_CUTOFF)						fill_pt = old_pt.clone();										else {						fill_pt = new Point((Math.random() * _dim_rect.width) << 0, (Math.random() * _dim_rect.height) << 0);						fail_cnt = 0;					}									} else {					fill_pt = fill_pt.subtract(_center_pt);										trace ("]>> FILLING #("+fill_cnt+") POS:["+fill_pt+"] RAD:["+rad+"]");					this.drawCircle(fill_pt, rad);					_src_bmpData.draw(_bmpHolder_sprite, new Matrix(1, 0, 0, 1, _center_pt.x, _center_pt.y));										_circleVO_arr.push(new CircleVO(fill_cnt++, fill_pt, rad));									}								fill_pt = fill_pt.add(this.offsetPt(rad));				//trace ("MOVING TO:["+fill_pt+"]\n[=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=]\n");			}		}				private function offsetPt(amt:int):Point {						var offset_pt:Point = new Point();						switch ((Math.random() * 4) << 0) {				case 0:					offset_pt.x = amt + OFFSET_RND;					break;										case 1:					offset_pt.x = -(amt + OFFSET_RND);					break;										case 2:					offset_pt.y = amt + OFFSET_RND;					break;										case 3:					offset_pt.y = -(amt + OFFSET_RND);					break;			}					return (offset_pt);		}				private function drawCircle(pos:Point, rad:int):void {						var g:Graphics;						g = _bmpHolder_sprite.graphics;			g.lineStyle(0, CIRCLE_STROKE, 0.00);			g.beginFill(CIRCLE_FILL);			g.drawCircle(pos.x, pos.y, rad);			g.endFill();						g = _gfx_sprite.graphics;			g.lineStyle(1, CIRCLE_STROKE);			g.beginFill(CIRCLE_FILL);			g.drawCircle(pos.x, pos.y, rad);			g.endFill();		}						private function testRadials(pos:Point, max:int):int {						for (var i:int=0; i<max; i++) {				var dist:int;				var testPos_pt:Point = new Point();				var offset_pt:Point = new Point();				var pixel_color:int;				var r_amt:int;				var g_amt:int;				var b_amt:int;												for (var j:int=0; j<360; j++) {					testPos_pt.x = (pos.x + (Math.sin(DEGREES_MULT * j) * i)) << 0;					testPos_pt.y = (pos.y + (Math.cos(DEGREES_MULT * j) * i)) << 0;										pixel_color = _src_bmpData.getPixel(testPos_pt.x, testPos_pt.y);					r_amt = (pixel_color >> 16) & 0xff;					g_amt = (pixel_color >> 8) & 0xff;					b_amt = (pixel_color >> 0) & 0xff;										if (pixel_color == BOUNDS_COLOR)						return (-1);										if (pixel_color == CIRCLE_FILL) {												offset_pt.x = Math.abs(testPos_pt.x - pos.x) << 0;						offset_pt.y = Math.abs(testPos_pt.y - pos.y) << 0;											//trace (">> RAD:["+i+"] ANG:["+j+"] POS:["+(testPos_pt.x-pos.x)+", "+(testPos_pt.y-pos.y)+"] COLOR:["+pixel_color+"] RGB:["+r_amt+","+g_amt+","+b_amt+"]");																		if (offset_pt.x > offset_pt.y)							return (offset_pt.x);												else							return (offset_pt.y);					}				}			}									return (0);		}				private function makeJoints():void {						var currVO:CircleVO;			var nextVO:CircleVO;						var g:Graphics = _gfx_sprite.graphics;				g.lineStyle(1, 0xff0000);							for (var i:Number=0; i<_circleVO_arr.length; i++) {				currVO = _circleVO_arr[i] as CircleVO;				nextVO = _circleVO_arr[i % (_circleVO_arr.length - 1)] as CircleVO;								//g.lineTo(currVO.pos_pt.x, currVO.pos_pt.y);				//g.moveTo(nextVO.pos_pt.x, nextVO.pos_pt.y);								_jointVO_arr.push(new JointVO(i, currVO.id, nextVO.id, new Point(), new Point(), SPRING_STR, SPRING_DAMP));			}		}						public function writePlist():String {						_plist_str += PLIST_HEAD;			_plist_str += this.writeCircles();			_plist_str += this.writeJoints();			_plist_str += PLIST_TAIL;											return (_plist_str);					}				private function writeCircles():String {						var str:String = CIRCLE_PREGRP;						for (var i:Number=0; i<_circleVO_arr.length; i++) {				str += CIRCLE_PRETAG + String((_circleVO_arr[i] as CircleVO).id);				str += CIRCLE_POS_X + String((_circleVO_arr[i] as CircleVO).pos_pt.x);				str += CIRCLE_POS_Y + String((_circleVO_arr[i] as CircleVO).pos_pt.y);				str += CIRCLE_RADIUS + String((_circleVO_arr[i] as CircleVO).radius);				str += CIRCLE_POSTTAG;			}						return (str + CIRCLE_POSTGRP);		}								private function writeJoints():String {						var str:String = JOINT_PREGRP;						for (var i:Number=0; i<_jointVO_arr.length; i++) {				str += JOINT_PRETAG + String((_jointVO_arr[i] as JointVO).id);				str += JOINT_BODY_A + String((_jointVO_arr[i] as JointVO).bodyA);				str += JOINT_BODY_B + String((_jointVO_arr[i] as JointVO).bodyB);				str += JOINT_STR + String((_jointVO_arr[i] as JointVO).str);				str += JOINT_DMP + String((_jointVO_arr[i] as JointVO).dmp);				str += JOINT_POSTTAG;			}						return (str + JOINT_POSTGRP);		}						private function guideSetup():void {						_guide_sprite = new Sprite();						var g:Graphics = _guide_sprite.graphics;				g.lineStyle(1, 0x00ffff);				g.moveTo(0, 0);				g.lineTo(0, -128);				g.moveTo(0, 0);				g.lineTo(128, 0);				g.moveTo(0, 0);				g.lineTo(0, 128);				g.moveTo(0, 0);				g.lineTo(-128, 0);				g.moveTo(0, 0);				g.drawCircle(0, 0, 96);											_root_sprite.addChild(_guide_sprite);					}						private function dummyPopulate(amt:int):void {						var i:Number;						for (i=0; i<amt; i++)				_circleVO_arr.push(new CircleVO(i, new Point(i, i), ((Math.random() * 62) << 0) + 2));											for (i=0; i<amt; i++)				_jointVO_arr.push(new JointVO(i, i, (i % 9), new Point(), new Point(), (Math.random() * 62) + 2, Math.random()));					}	}}